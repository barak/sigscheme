@node Features
@chapter Features

@comment Keep synchronized with spec.txt for now -- YamaKen 2006-04-04

@comment Following texts other than ``SRFIs'' and ``Multibyte String'' are converted from spec.txt (``Specifications of SigScheme''). These texts will be reorganized into another chapter or document since it is too excessively described for ``features''. ``features'' should be a summary, and specifications are not. The two should be distinguished and separated.  -- YamaKen 2006-04-04

@menu
* General::
* R5RS conformance::
* SRFI conformance::
* SIOD compatibility::
* SRFIs::
* Multibyte String::
@end menu

@node General
@section General

@table @b
@item 64-bit data models

Supports LL64, LLP64, LP64 and ILP64 (storage-fatty). storage-compact does not support any of above (yet)
@comment Reform into nested itemized text as original text does
@comment   - 64-bit data models
@comment 
@comment     * Supports LL64, LLP64, LP64 and ILP64 (storage-fatty)
@comment 
@comment     * storage-compact does not support any of above (yet)

@item Addressable memory space

Ordinary storage implementation can address any Scheme object scattered on whole memory space. Both storage-fatty and storage-compact have no limitation on any 32 and 64-bit data models. But it may be limited if a storage implementation is designed to do so for some specific advantages, as like GNU Emacs' 28-bit tagged pointer does.

@item Integer range
Only supports fixnum, and its range is varied by the user-selected underlying storage implementation. The range can be known via SRFI-77 compatible (least-fixnum) and (greatest-fixnum).
@end table

@node R5RS conformance
@section R5RS conformance

@comment Added by Kazuki to reform spec.txt into ``features''
@comment SigScheme basically conforms to ``Revised^5 Report of Algorithmic Language Scheme'' (@ref{r5rs,[R5RS],R5RS}), except the following features.

@table @b
@item Proper tail recursion

Supported.

@item Macros

Not supported (yet).

@item Continuations

Limited to nested use due to its setjmp/longjmp implementation. If a continuation that is not an ancestor of current continuation called, all continuation objects lying between the curent and the common ancestor of the destination are invalidated. Calling an invalidated continuation object causes an error.

@item Numbers

Only integer part is implemented.

@item Characters

All character category-sensitive procedures and predicates (such as char-upcase) work correctly only in ASCII range. i.e. Neigher Unicode processing specified in SRFI-75 nor other non-Unicode multibyte character processing are supported in such procedures/predicates.

@item Case-insensitive character comparison

SigScheme's case-insensitive comparison conforms to the foldcase'ed comparison described in SRFI-75 and SRFI-13, although R5RS does not specify comparison between alphabetic and non-alphabetic char.

See the description in operations.c for further details.

@item Case-sensitive identifiers

SigScheme does distinguish letter case in indentifiers. Although case insensitivity is required in R5RS as follows, it is hard to accept for the our application.

@example
> 2. Lexical conventions
> 
> Upper and lower case forms of a letter are never distinguished except
> within character and string constants. For example, `Foo' is the same
> identifier as `FOO', and #x1AB is the same number as #X1ab.
@end example

@item Constant string

SigScheme treats string literals as constant as specified in R5RS.

@example
sscm> (string-set! "foo" 0 #\F)
Error: in string-set!: attempted to modify immutable string: "foo"

sscm> (string-set! (string-copy "foo") 0 #\F)
"Foo"
@end example

@item Constant list

SigScheme inhibits modification of constant list object by default as specified in R5RS, if the storage implementation suports it. storage-fatty supports it, but storage-compact does not due to no bit space for pair object.

The behavior can be changed by SCM_CONST_LIST_LITERAL.

@example
> 4.1.2 Literal expressions
> 
>     `(quote <datum>)' may be abbreviated as '<datum>. The two notations
>     are equivalent in all respects.
>    
>     'a                                     ==>  a
>     '#(a b c)                              ==>  #(a b c)
>     '()                                    ==>  ()
>     '(+ 1 2)                               ==>  (+ 1 2)
>     '(quote a)                             ==>  (quote a)
>     ''a                                    ==>  (quote a)
> 
>     As noted in section 3.4 Storage model, it is an error to alter a
>     constant (i.e. the value of a literal expression) using a mutation
>     procedure like `set-car!' or `string-set!'.

> 6.3.2 Pairs and lists
> 
> procedure: set-car! pair obj
>    
>     Stores obj in the car field of pair. The value returned by `set-car!'
>     is unspecified.
>    
>     (define (g) '(constant-list))
>     (set-car! (g) 3)                       ==>  error
@end example

@item Constant vector

SigScheme inhibits modification of constant vector object by default as specified in R5RS, if the storage implementation suports it. storage-fatty supports it, but storage-compact is not yet.

The behavior can be changed by SCM_CONST_VECTOR_LITERAL.

@example
> 6.3.6 Vectors
>
> procedure: vector-set! vector k obj
>
>     (vector-set! '#(0 1 2) 1 "doe")
>               ==>  error  ; constant vector
@end example

@item Quote-less null list

SigScheme allows quote-less null list by default for convenience and performance. But it can be error as specified in R5RS, when SCM_STRICT_R5RS is enabled.

SCM_STRICT_R5RS disabled:

@example
sscm> (null? ())
#t
@end example

SCM_STRICT_R5RS enabled:

@example
sscm> (null? ())
Error: eval: () is not a valid R5RS form. use '() instead
@end example

@item Quote-less vector literal

Sigscheme inhibits quote-less vector literal by default, as specified in R5RS.

The behavior can be changed by SCM_STRICT_VECTOR_FORM.

@example
> 6.3.6 Vectors
>
> Vectors are written using the notation #(obj ...). For example, a vector
> of length 3 containing the number zero in element 0, the list `(2 2 2 2)'
> in element 1, and the string `"Anna"' in element 2 can be written as
> following:
>
> #(0 (2 2 2 2) "Anna")
>
> Note that this is the external representation of a vector, not an
> expression evaluating to a vector. Like list constants, vector constants
> must be quoted:
>
> '#(0 (2 2 2 2) "Anna")
>           ==>  #(0 (2 2 2 2) "Anna")
@end example

@example
sscm> #(1 2 3)
Error: eval: #() is not a valid R5RS form. use '#() instead
sscm> '#(1 2 3)
#(1 2 3)
@end example

@item Environment specifiers

(null-environment) and (scheme-report-environment) does not return correct environemnt specified in R5RS. Current implementation returns same object of (interaction-environment).

@item Internal definitions

FIXME

@item Dotted list as arguments

FIXME

@item Procedures not implemented

Following R5RS procedures are not implemented (yet).

@table @b
@item Numbers
@itemize @bullet
@item procedure: complex? obj
@item procedure: real? obj
@item procedure: rational? obj
@item procedure: exact? z
@item procedure: inexact? z
@item library procedure: gcd n1 ...
@item library procedure: lcm n1 ...
@item procedure: numerator q
@item procedure: denominator q
@item procedure: floor x
@item procedure: ceiling x
@item procedure: truncate x
@item procedure: round x
@item library procedure: rationalize x y
@item procedure: exp z
@item procedure: log z
@item procedure: sin z
@item procedure: cos z
@item procedure: tan z
@item procedure: asin z
@item procedure: acos z
@item procedure: atan z
@item procedure: atan y x
@item procedure: sqrt z
@item procedure: expt z1 z2
@item procedure: make-rectangular x1 x2
@item procedure: make-polar x3 x4
@item procedure: real-part z
@item procedure: imag-part z
@item procedure: magnitude z
@item procedure: angle z
@item procedure: exact->inexact z
@item procedure: inexact->exact z
@end itemize
@end table

@end table

@node SRFI conformance
@section SRFI conformance

@verbatim
  - SRFI-48

    The 'd' part of ~w,dF directive is acceptable, but completely ignored on
    output format. Since SigScheme only supports integer currently, number is
    always formatted as integer even if the 'd' part is specified.

    proper behavior:
      (format "~3F"   3)  => "  3"
      (format "~3,2F" 3)  => "3.00"

    SigScheme:
      (format "~3F"   3)  => "  3"
      (format "~3,2F" 3)  => "  3"
@end verbatim

@node SIOD compatibility
@section SIOD compatibility

@itemize @bullet
@item #f and '()
@item let and let* bindings
@item '=' predicate
@end itemize



@comment Following texts are written by Kazuki as ``features''

@node SRFIs
@section SRFIs

SigScheme supports following SRFIs. You can choose which SRFI to include at the build process.

@table @asis
@item SRFI-6, Basic String Ports
@item SRFI-8, receive: Binding to multiple values
@item SRFI-23, Error reporting mechanism
@item SRFI-34, Exception Handling for Programs
@item SRFI-38, External Representation for Data With Shared Structure
@item SRFI-60, Integers as Bits
@end table


@node Multibyte String
@section Multibyte String

SigScheme supports multibyte string handling. Currently, it supports UTF-8, EUC-JP, EUC-CN, EUC-KR, Shift-Jis.
