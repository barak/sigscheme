Specifications of SigScheme

* General

  - Integer range

    To be described.

  - 64bit environment is being supported

* R5RS conformance

  - Proper tail recursion

    Supported.

  - Macros

    Not supported (yet).

  - Continuations

    Limited to nested use due to its setjmp/longjmp implementation. If a
    continuation that is not an ancestor of current continuation called, all
    continuation objects lying between the curent and the common ancestor of
    the destination are invalidated. Calling an invalidated continuation object
    causes an error.

  - Numbers

    Integer part is only implemented.

  - Characters

    All character category-sensitive procedures and predicates (such as
    char-upcase) work correctly only in ASCII range. i.e. Neigher Unicode
    processing specified in SRFI-75 nor other non-Unicode multibyte character
    processing are supported in such procedures/predicates.

  - Case-sensitive identifiers

    SigScheme does distinguish letter case in indentifiers. Although case
    insensitivity is required in R5RS as follows, it is hard to accept for the
    our application.

    > 2. Lexical conventions
    > 
    > Upper and lower case forms of a letter are never distinguished except
    > within character and string constants. For example, `Foo' is the same
    > identifier as `FOO', and #x1AB is the same number as #X1ab.

  - Constant string

    SigScheme treats string literals as constant as specified in R5RS.

    sscm> (string-set! "foo" 0 #\F)
    Error: in string-set!: attempted to modify immutable string: "foo"

    sscm> (string-set! (string-copy "foo") 0 #\F)
    "Foo"

  - Constant list

    SigScheme allows modification of constant list object for convenience
    although it is required to be an error in R5RS.

    > 4.1.2 Literal expressions
    > 
    >     `(quote <datum>)' may be abbreviated as '<datum>. The two notations
    >     are equivalent in all respects.
    >    
    >     'a                                     ==>  a
    >     '#(a b c)                              ==>  #(a b c)
    >     '()                                    ==>  ()
    >     '(+ 1 2)                               ==>  (+ 1 2)
    >     '(quote a)                             ==>  (quote a)
    >     ''a                                    ==>  (quote a)
    > 
    >     As noted in section 3.4 Storage model, it is an error to alter a
    >     constant (i.e. the value of a literal expression) using a mutation
    >     procedure like `set-car!' or `string-set!'.

    > 6.3.2 Pairs and lists
    > 
    > procedure: set-car! pair obj
    >    
    >     Stores obj in the car field of pair. The value returned by `set-car!'
    >     is unspecified.
    >    
    >     (define (g) '(constant-list))
    >     (set-car! (g) 3)                       ==>  error

    sscm> (define (g) '(constant-list))
    (g)
    sscm> (set-car! (g) 3)
    3

    The object is modified as (3) in SigScheme. Gauche and Guile are also
    behaves so.

  - Constant vector

    SigScheme allows modification of constant vector object for convenience
    although it is required to be an error in R5RS.

    > 6.3.6 Vectors
    > 
    > procedure: vector-set! vector k obj
    > 
    >     (vector-set! '#(0 1 2) 1 "doe")
    >               ==>  error  ; constant vector

    The object is modified as #(0 "doe" 2) in SigScheme. Gauche and Guile are
    also behaves so.

  - Quote-less null list

    SigScheme allows quote-less null list by default for convenience and
    performance. But it can be error as specified in R5RS, when SCM_STRICT_R5RS
    is enabled.

    SCM_STRICT_R5RS disabled:

    sscm> (null? ())
    #t

    SCM_STRICT_R5RS enabled:

    sscm> (null? ())
    Error: eval: () is not a valid R5RS form. use '() instead

  - Quote-less vector literal

    Sigscheme allows quote-less vector literal for convenience, although
    quotation is required in formal R5RS syntax. This specification may be
    changed to make notation rule consistent with constant list.

    > 6.3.6 Vectors
    > 
    > Vectors are written using the notation #(obj ...). For example, a vector
    > of length 3 containing the number zero in element 0, the list `(2 2 2 2)'
    > in element 1, and the string `"Anna"' in element 2 can be written as
    > following:
    > 
    > #(0 (2 2 2 2) "Anna")
    >
    > Note that this is the external representation of a vector, not an
    > expression evaluating to a vector. Like list constants, vector constants
    > must be quoted:
    > 
    > '#(0 (2 2 2 2) "Anna")  
    >           ==>  #(0 (2 2 2 2) "Anna")

    sscm> #(1 2 3)
    #(1 2 3)
    sscm> '#(1 2 3)
    #(1 2 3)

    Gauche and Guile are also behaves above.

  - Environment specifiers

    (null-environment) and (scheme-report-environment) does not return correct
    environemnt specified in R5RS. Current implementation returns same object
    of (interaction-environment).

  - Internal definitions

    FIXME

  - Dotted list as arguments

    FIXME

  - Procedures not implemented

    Following R5RS procedures are not implemented (yet).

    * Numbers

      procedure: complex? obj
      procedure: real? obj
      procedure: rational? obj
      procedure: exact? z
      procedure: inexact? z
      library procedure: gcd n1 ...
      library procedure: lcm n1 ...
      procedure: numerator q
      procedure: denominator q
      procedure: floor x
      procedure: ceiling x
      procedure: truncate x
      procedure: round x
      library procedure: rationalize x y
      procedure: exp z
      procedure: log z
      procedure: sin z
      procedure: cos z
      procedure: tan z
      procedure: asin z
      procedure: acos z
      procedure: atan z
      procedure: atan y x
      procedure: sqrt z
      procedure: expt z1 z2
      procedure: make-rectangular x1 x2
      procedure: make-polar x3 x4
      procedure: real-part z
      procedure: imag-part z
      procedure: magnitude z
      procedure: angle z
      procedure: exact->inexact z
      procedure: inexact->exact z

* SIOD compatibility

  - #f and '()

  - let and let* bindings

  - '=' predicate
